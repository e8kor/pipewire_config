# Daemon config file for PipeWire version "0.3.56" #
#
# Copy and edit this file in /etc/pipewire for system-wide changes
# or in ~/.config/pipewire for local changes.
#
# It is also possible to place a file with an updated section in
# /etc/pipewire/pipewire.conf.d/ for system-wide changes or in
# ~/.config/pipewire/pipewire.conf.d/ for local changes.
#

context.properties = {
    ## Configure properties in the system.
    #library.name.system                   = support/libspa-support
    #context.data-loop.library.name.system = support/libspa-support
    #support.dbus                          = true
    #link.max-buffers                      = 64
    link.max-buffers                       = 16                       # version < 3 clients can't handle more
    #mem.warn-mlock                        = false
    #mem.allow-mlock                       = true
    #mem.mlock-all                         = false
    #clock.power-of-two-quantum            = true
    log.level                              = 3
    #cpu.zero.denormals                    = false

    core.daemon = true              # listening for socket connections
    core.name   = pipewire-0        # core name and socket name

    ## Properties for the DSP configuration.
    #default.clock.rate          = 48000
    default.clock.allowed-rates = [ 48000 88200 96000 176400 192000 352800 384000 ]
    #default.clock.quantum       = 1024
    default.clock.min-quantum   = 16
    #default.clock.max-quantum   = 2048
    #default.clock.quantum-limit = 8192
    #default.video.width         = 640
    #default.video.height        = 480
    #default.video.rate.num      = 25
    #default.video.rate.denom    = 1
    #
    #settings.check-quantum      = false
    #settings.check-rate         = false
    #
    # These overrides are only applied when running in a vm.
    vm.overrides = {
        default.clock.min-quantum = 1024
	default.clock.quantum = 2048
    }
}

context.spa-libs = {
    #<factory-name regex> = <library-name>
    #
    # Used to find spa factory names. It maps an spa factory name
    # regular expression to a library name that should contain
    # that factory.
    #
    audio.convert.* = audioconvert/libspa-audioconvert
    avb.*           = avb/libspa-avb
    api.alsa.*      = alsa/libspa-alsa
    api.v4l2.*      = v4l2/libspa-v4l2
    api.libcamera.* = libcamera/libspa-libcamera
    api.bluez5.*    = bluez5/libspa-bluez5
    api.vulkan.*    = vulkan/libspa-vulkan
    api.jack.*      = jack/libspa-jack
    support.*       = support/libspa-support
    #videotestsrc   = videotestsrc/libspa-videotestsrc
    #audiotestsrc   = audiotestsrc/libspa-audiotestsrc
}

context.modules = [
    #{ name = <module-name>
    #    [ args  = { <key> = <value> ... } ]
    #    [ flags = [ [ ifexists ] [ nofail ] ]
    #}
    #
    # Loads a module with the given parameters.
    # If ifexists is given, the module is ignored when it is not found.
    # If nofail is given, module initialization failures are ignored.
    #

    # Uses realtime scheduling to boost the audio thread priorities. This uses
    # RTKit if the user doesn't have permission to use regular realtime
    # scheduling.
    
    { name = libpipewire-module-rt
        args = {
            nice.level    = -11
            #rt.prio      = 88
            #rt.time.soft = -1
            #rt.time.hard = -1
        }
        flags = [ ifexists nofail ]
    }

    # The native communication protocol.
    { name = libpipewire-module-protocol-native }

    # The profile module. Allows application to access profiler
    # and performance data. It provides an interface that is used
    # by pw-top and pw-profiler.
    { name = libpipewire-module-profiler }

    # Allows applications to create metadata objects. It creates
    # a factory for Metadata objects.
    { name = libpipewire-module-metadata }

    # Creates a factory for making devices that run in the
    # context of the PipeWire server.
    { name = libpipewire-module-spa-device-factory }

    # Creates a factory for making nodes that run in the
    # context of the PipeWire server.
    { name = libpipewire-module-spa-node-factory }

    # Allows creating nodes that run in the context of the
    # client. Is used by all clients that want to provide
    # data to PipeWire.
    { name = libpipewire-module-client-node }

    # Allows creating devices that run in the context of the
    # client. Is used by the session manager.
    { name = libpipewire-module-client-device }

    # The portal module monitors the PID of the portal process
    # and tags connections with the same PID as portal
    # connections.
    { name = libpipewire-module-portal
        flags = [ ifexists nofail ]
    }

    # The access module can perform access checks and block
    # new clients.
    { name = libpipewire-module-access
        args = {
            # access.allowed to list an array of paths of allowed
            # apps.
            #access.allowed = [
            #    /usr/bin/pipewire-media-session
            #]

            # An array of rejected paths.
            #access.rejected = [ ]

            # An array of paths with restricted access.
            #access.restricted = [ ]

            # Anything not in the above lists gets assigned the
            # access.force permission.
            #access.force = flatpak
        }
    }

    # Makes a factory for wrapping nodes in an adapter with a
    # converter and resampler.
    { name = libpipewire-module-adapter }

    # Makes a factory for creating links between ports.
    { name = libpipewire-module-link-factory }

    # Provides factories to make session manager objects.
    { name = libpipewire-module-session-manager }

    # {   name = libpipewire-module-loopback
    #     args = {
    #         audio.position = [ FL FR ]
    #         node.name = "Multimedia Audio"
    #         node.description = "Multimedia Audio Virtual Hub"
    #         capture.props = {
    #             media.class      = Audio/Sink
    #             node.name        = "Multimedia Sink"
    #             target.object    = "multimedia-sink"
    #             media.user.role  = "media"
    #         }
    #         playback.props = {
    #             media.class      = Audio/Source
    #             node.name        = "Multimedia Source"
    #             target.object    = "multimedia-source"
    #             media.user.role  = "media"
    #         }
    #     }
    # }
    # {   name = libpipewire-module-loopback
    #     args = {
    #         audio.position = [ FL FR ]
    #         node.name = "Communication Foreground Audio"
    #         node.description = "Communication Foreground Audio Virtual Hub"
    #         capture.props = {
    #             media.class      = Audio/Sink
    #             node.name        = "Communication Foreground Sink"
    #             target.object    = "communication-foreground-sink"
    #             media.user.role  = "comm"
    #         }
    #         playback.props = {
    #             media.class      = Audio/Source
    #             node.name        = "Communication Foreground Source"
    #             target.object    = "communication-foreground-source"
    #             media.user.role  = "comm"
    #         }
    #     }
    # }
    # {   name = libpipewire-module-loopback
    #     args = {
    #         audio.position = [ FL FR ]
    #         node.name = "Communication Background Audio"
    #         node.description = "Communication Background Audio Virtual Hub"
    #         capture.props = {
    #             media.class      = Audio/Sink
    #             node.name        = "Communication Background Sink"
    #             target.object    = "communication-background-sink"
    #             media.user.role  = "comm-background"
    #         }
    #         playback.props = {
    #             media.class      = Audio/Source
    #             node.name        = "Communication Background Source"
    #             target.object    = "communication-follower-source"
    #             media.user.role  = "comm-background"
    #         }
    #     }
    # }
    # {   name = libpipewire-module-loopback
    #     args = {
    #         audio.position = [ FL FR ]
    #         node.name = "Workspace Audio Hub"
    #         node.description = "Workspace Audio Virtual Hub"
    #         capture.props = {
    #             media.class      = Audio/Sink
    #             node.name        = "Workspace Sink"
    #             target.object    = "workspace-sink"
    #             media.user.role  = "work"
    #         }
    #         playback.props = {
    #             media.class      = Audio/Source
    #             node.name        = "Workspace Source"
    #             target.object    = "workspace-source"
    #             media.user.role  = "work"
    #         }
    #     }
    # }
    # Use libcanberra to play X11 Bell
    #{ name = libpipewire-module-x11-bell
    #  args = {
    #      #sink.name = ""
    #      #sample.name = "bell-window-system"
    #      #x11.display = null
    #      #x11.xauthority = null
    #  }
    # }
]

context.objects = [
    # Default channels, no real devices listens to them{ factory = adapter
    # {
    #    args = {
    #         factory.name     = support.null-audio-sink
    #         audio.position   = [ FL FR ]
    #         node.name        = "Virtual Video Device"
    #         node.description = "Virtual Video Device"
    #         media.class      = Video/Source/Virtual
    #         media.user.role  = "video"
    #    }
    # }
    
    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Background Sink"
            node.description = "Background Audio Hub"
            media.class      = Audio/Sink
            media.user.role  = "background"
       }
    }

    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Background Source"
            node.description = "Background Audio Hub"
            media.class      = Audio/Source/Virtual
            media.user.role  = "background"
       }
    }

    # Communication channels, used as input and output devices
    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Communication Sink"
            node.description = "Communication Audio Hub"
            media.class      = Audio/Sink
            media.user.role  = "comm"
       }
    }

    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Communication Source"
            node.description = "Communication Audio Hub"
            media.class      = Audio/Source/Virtual
            media.user.role  = "comm"
       }
    }

    # Multimedia channels, used for browser
    { factory = adapter
       args = {
            node.name        = "Multimedia"
            node.description = "Multimedia Hub"
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            media.class      = Audio/Source/Virtual
            media.user.role  = "media"
       }
    }

    { factory = adapter
       args = {
            node.name        = "Multimedia"
            node.description = "Multimedia Hub"
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            media.class      = Audio/Sink
            media.user.role  = "media"
       }
    }

    # Work channels, used for virtual machines
    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Workspace Sink"
            node.description = "Workspace Audio Hub"
            media.class      = Audio/Sink
            media.user.role  = "work"
       }
    }

    { factory = adapter
       args = {
            factory.name     = support.null-audio-sink
            audio.position   = [ FL FR ]
            node.name        = "Workspace Source"
            node.description = "Workspace Audio Hub"
            media.class      = Audio/Source/Virtual
            media.user.role  = "work"
       }
    }

    #{ factory = <factory-name>
    #    [ args  = { <key> = <value> ... } ]
    #    [ flags = [ [ nofail ] ]
    #}
    #
    # Creates an object from a PipeWire factory with the given parameters.
    # If nofail is given, errors are ignored (and no object is created).
    #
    #{ factory = spa-node-factory   args = { factory.name = videotestsrc node.name = videotestsrc Spa:Pod:Object:Param:Props:patternType = 1 } }
    #{ factory = spa-device-factory args = { factory.name = api.jack.device foo=bar } flags = [ nofail ] }
    #{ factory = spa-device-factory args = { factory.name = api.alsa.enum.udev } }
    #{ factory = spa-node-factory   args = { factory.name = api.alsa.seq.bridge node.name = Internal-MIDI-Bridge } }
    #{ factory = adapter            args = { factory.name = audiotestsrc node.name = my-test } }
    #{ factory = spa-node-factory   args = { factory.name = api.vulkan.compute.source node.name = my-compute-source } }

    # A default dummy driver. This handles nodes marked with the "node.always-driver"
    # property when no other driver is currently active. JACK clients need this.
    # { factory = spa-node-factory
    #     args = {
    #         factory.name    = support.node.driver
    #         node.name       = Dummy-Driver
    #         node.group      = pipewire.dummy
    #         priority.driver = 20000
    #     }
    # }
    # { factory = spa-node-factory
    #     args = {
    #         factory.name    = support.node.driver
    #         node.name       = Freewheel-Driver
    #         priority.driver = 19000
    #         node.group      = pipewire.freewheel
    #         node.freewheel  = true
    #     }
    # }
    # This creates a new Source node. It will have input ports
    # that you can link, to provide audio for this source.
    #{ factory = adapter
    #    args = {
    #        factory.name     = support.null-audio-sink
    #        node.name        = "my-mic"
    #        node.description = "Microphone"
    #        media.class      = "Audio/Source/Virtual"
    #        audio.position   = "FL,FR"
    #    }
    #}

    # This creates a single PCM source device for the given
    # alsa device path hw:0. You can change source to sink
    # to make a sink in the same way.
    #{ factory = adapter
    #    args = {
    #        factory.name           = api.alsa.pcm.source
    #        node.name              = "alsa-source"
    #        node.description       = "PCM Source"
    #        media.class            = "Audio/Source"
    #        api.alsa.path          = "hw:0"
    #        api.alsa.period-size   = 1024
    #        api.alsa.headroom      = 0
    #        api.alsa.disable-mmap  = false
    #        api.alsa.disable-batch = false
    #        audio.format           = "S16LE"
    #        audio.rate             = 48000
    #        audio.channels         = 2
    #        audio.position         = "FL,FR"
    #    }
    #}
]

context.exec = [
    #{ path = <program-name> [ args = "<arguments>" ] }
    #
    # Execute the given program with arguments.
    #
    # You can optionally start the session manager here,
    # but it is better to start it as a systemd service.
    # Run the session manager with -h for options.
    #
    #{ path = "/usr/bin/pipewire-media-session" args = "" }
    #
    # You can optionally start the pulseaudio-server here as well
    # but it is better to start it as a systemd service.
    # It can be interesting to start another daemon here that listens
    # on another address with the -a option (eg. -a tcp:4713).
    #
    #{ path = "/usr/bin/pipewire" args = "-c pipewire-pulse.conf" }
]
